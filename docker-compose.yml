services:
  # ===========================================
  # REDIS SERVICE
  # In-memory data store for BullMQ job queue
  # ===========================================
  redis:
    image: redis:7-alpine
    restart: always
    command: redis-server --requirepass ${REDIS_PASSWORD:-your_redis_password}
    ports:
      - "6379:6379"  # Expose for host network access
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
    volumes:
      - redis_data:/data
    networks:
      - app_network

  # ===========================================
  # POSTGRESQL SERVICE
  # Database for message logs
  # ===========================================
  postgres:
    image: postgres:16-alpine
    restart: always
    ports:
      - "5432:5432"  # Expose for host network access
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -h localhost"]
      interval: 5s
      timeout: 5s
      retries: 10
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-your_postgres_password}
      POSTGRES_DB: ${POSTGRES_DB:-message_sender}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app_network

  # ===========================================
  # RUN PROCESSOR SERVICE
  # Polls Supabase for pending runs and enqueues messages
  # ===========================================
  run-processor:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    depends_on:
      redis:
        condition: service_healthy
      postgres:
        condition: service_healthy
    env_file:
      - .env
    environment:
      SERVICE_TYPE: run-processor
      NODE_ENV: production

      # Redis
      REDIS_HOST: ${REDIS_HOST}
      REDIS_PORT: ${REDIS_PORT}
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_DB: ${REDIS_DB}

      # PostgreSQL
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_SCHEMA: ${POSTGRES_SCHEMA}

      # Supabase
      SUPABASE_URL: ${SUPABASE_URL}
      SUPABASE_SERVICE_ROLE_KEY: ${SUPABASE_SERVICE_ROLE_KEY}

      # Configuration
      POLL_INTERVAL_MS: ${POLL_INTERVAL_MS}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - app_network

  # ===========================================
  # MESSAGE WORKER SERVICE
  # Consumes queue and sends messages to Facebook
  # ===========================================
  message-worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    network_mode: host  # Use host network for internet access to Facebook API
    depends_on:
      redis:
        condition: service_healthy
      postgres:
        condition: service_healthy
    env_file:
      - .env
    environment:
      SERVICE_TYPE: message-worker
      NODE_ENV: production

      # Redis - using localhost since we're on host network
      REDIS_HOST: localhost
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_DB: ${REDIS_DB}

      # PostgreSQL - using localhost since we're on host network
      POSTGRES_HOST: localhost
      POSTGRES_PORT: 5432
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_SCHEMA: ${POSTGRES_SCHEMA}

      # Supabase
      SUPABASE_URL: ${SUPABASE_URL}
      SUPABASE_SERVICE_ROLE_KEY: ${SUPABASE_SERVICE_ROLE_KEY}

      # Worker Configuration
      WORKER_CONCURRENCY: ${WORKER_CONCURRENCY}
      MAX_SOCKETS: ${MAX_SOCKETS}

      # Logging
      LOG_LEVEL: ${LOG_LEVEL}
      LOG_BATCH_SIZE: ${LOG_BATCH_SIZE}
      LOG_BATCH_INTERVAL_MS: ${LOG_BATCH_INTERVAL_MS}

      # Rate Limiting
      RATE_LIMIT_MAX_JOBS_PER_SECOND: ${RATE_LIMIT_MAX_JOBS_PER_SECOND}
      RATE_LIMIT_PER_PAGE: ${RATE_LIMIT_PER_PAGE}

      # Circuit Breaker
      CIRCUIT_BREAKER_ENABLED: ${CIRCUIT_BREAKER_ENABLED}
      CIRCUIT_BREAKER_THRESHOLD: ${CIRCUIT_BREAKER_THRESHOLD}
      CIRCUIT_BREAKER_TIMEOUT_MS: ${CIRCUIT_BREAKER_TIMEOUT_MS}
    deploy:
      replicas: 2  # 2 workers Ã— 50 concurrency = 100 jobs in parallel

  # ===========================================
  # API SERVICE
  # Bull Board UI + Health checks + Metrics
  # ===========================================
  api:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s
    depends_on:
      redis:
        condition: service_healthy
      postgres:
        condition: service_healthy
    env_file:
      - .env
    environment:
      SERVICE_TYPE: api
      NODE_ENV: production

      # Redis
      REDIS_HOST: ${REDIS_HOST}
      REDIS_PORT: ${REDIS_PORT}
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_DB: ${REDIS_DB}

      # PostgreSQL
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_SCHEMA: ${POSTGRES_SCHEMA}

      # API Configuration
      API_PORT: ${API_PORT}
      API_ENABLE_BULL_BOARD: ${API_ENABLE_BULL_BOARD}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - app_network


# ===========================================
# VOLUMES
# ===========================================
volumes:
  redis_data:
    driver: local
  postgres_data:
    driver: local

# ===========================================
# NETWORKING
# ===========================================
# Create a custom bridge network to ensure:
# 1. Services can communicate with each other by name (redis, postgres, etc)
# 2. Services have internet access for external APIs (Facebook Graph API)
networks:
  app_network:
    driver: bridge
